%! Author = adnansiddiquei
%! Date = 08/12/2023

\section{Documentation, Packaging and Usability}\label{sec:documentation-packaging-and-usability}
    \subsection{Documentation - \inlinecode{sphinx} and NumPy Style Docstrings}\label{subsec:documentation-sphinx}
    Documentation is an important part of any software project, without it, the user would have no idea how to utilise
    third-party packages.
    Documentation comes in two forms: inline documentation (docstrings, comments and type definitions) and usage
    documentation (user guides and API references).
    The former is written whilst developing the code, and the latter is generated from the former with documentation tools.

    The discussion of which documentation tool to use is quite an opinionated one, there is no strict "one is better than
    the other" in most cases.
    The two most popular ones in python are \inlinecode{sphinx} and \inlinecode{doxygen}.
    Whilst using either of these tools would have been sufficient, \inlinecode{sphinx} was chosen for this project
    primarily because of the vast universe of themes and extensions available for it.
    The reason for documentation is to help a user understand how to use the package, and as such, above all else
    the documentation output should be easy to read and navigate.
    \inlinecode{sphinx} has a number of themes available, and the one chosen for this project was \inlinecode{furo} which
    is used by \inlinecode{pip} \cite{pip-docs}\, \inlinecode{black} \cite{black-docs} and the python developer's guide
    \cite{python-devguide}.
    Whilst the setup for \inlinecode{sphinx} was a bit more hands on, it resulted in much more usable and aesthetic docs.

    Another motivator for using \inlinecode{sphinx} was the ability to use NumPy style docstrings.
    More so than the desire to use NumPy style docstrings, was the desire to not use Epytext style or reStructuredText style
    docstrings, which is what Doxygen requires.
    We found these styles to be much less readable than NumPy style docstrings, which was another motivator for using
    \inlinecode{sphinx}.
    Another popular alternative is Google style doctrings, NumPy style was chosen only by personal preference, \inlinecode{sphinx}
    can handle both.

    \subsection{Packaging - conda, Docker and make}\label{subsec:packaging}
    Packaging the code effectively is important for usability.
    Docker allows us to containerise the code and run it on any machine and as such, we created a \inlinecode{Dockerfile}
    for our project which would allow the user to run the code in a Docker container.

    We also utilised \inlinecode{make} by creating a \inlinecode{Makefile} which would allow the user to easily build
    and run the docker image.
    The \inlinecode{Makefile} contained a \inlinecode{make run} target which would build the docker image, then run
    the code in the container with the relevant directories mounted, and finally place the user in a shell in the container
    so that they could interact with the code.
    This way, the user does not need to worry about understanding which directories need to be mounted or any other
    config with relation to getting the Docker container started.
    If the user did care to know, they could simply look at the \inlinecode{Makefile} and see what the \inlinecode{run}
    target does.

    Conda was also utilised to create and manage environments for the code.
    The base image for the Docker container was \inlinecode{continuumio/miniconda3}, which allowed us to easily create
    and install all the dependencies for the Docker image using an \inlinecode{environment.yaml} file and conda.

    Generally, the purposes of these tools were to make the code as easy as possible to run by any user, and
    this goal was achieved through the use of these tools.
